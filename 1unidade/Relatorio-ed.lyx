#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\float_placement H
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename ufrn-logo-EEBB3B5235-seeklogo.com.png
	width 3cm
	height 3cm

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\paragraph_spacing other 2
\align center
UNIVERSIDADE FEDERAL DO RIO GRANDE DO NORTE – UFRN 
\end_layout

\begin_layout Standard
\paragraph_spacing other 2
\align center
CENTRO DE ENSINO SUPERIOR DO SERIDO – CERES 
\end_layout

\begin_layout Standard
\paragraph_spacing other 2
\align center
DEPARTAMENTO DE COMPUTAÇÃO E TECNOLOGIA – DCT 
\end_layout

\begin_layout Standard
\paragraph_spacing other 2
\align center
BACHARELADO EM SISTEMAS DE INFORMACAO 
\end_layout

\begin_layout Standard
\paragraph_spacing other 2
\align center
Prof.
 DSc.
 JOAO PAULO DE SOUZA MEDEIROS
\end_layout

\begin_layout Standard
\paragraph_spacing other 5
\align center

\series bold
MATEUS MEDEIROS DE ARAÚJO
\end_layout

\begin_layout Standard
\paragraph_spacing other 5
\align center
TRABALHO DE IMPLEMENTAÇÃO UNIDADE I
\end_layout

\begin_layout Standard
\paragraph_spacing double
\align center
Caicó – RN
\end_layout

\begin_layout Standard
\paragraph_spacing double
\align center
Abril - 2018
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\align center

\size larger
Resumo
\end_layout

\begin_layout Standard
O presente relatório tem como objetivo apresentar estudos coletados durante
 a primeira unidade da disciplina de estrutura de dados ministrada pelo
 professor DSc.
 João Paulo de Souza Medeiros na Universidade Federal do Rio Grande no Norte.
 Serão apresentados gráficos e informações acerca de alguns algoritmos de
 ordenação, sendo eles couting sort, insertion sort, merge sort, quick sort,
 distribution sort e bubble sort.
 Além de outros algoritmos de busca.
 Para implementação dos códigos foi utilizado o sistema operacional Linux
 Mint, a linguagem de programação C, o compilador GCC.
 A ferramenta GNUPLOT foi utilizada para criação dos gráficos.
\end_layout

\begin_layout Standard
\align center

\size larger
Abstract
\end_layout

\begin_layout Standard
This report aims to present studies collected during the first unit of the
 discipline of data structure taught by the teacher DSc.
 João Paulo de Souza Medeiros at the Federal University of Rio Grande do
 Norte.
 Graphs and information about some sort algorithms will be presented, being
 couting sort, insertion sort, merge sort, quick sort, distribution sort
 and bubble sort.
 In addition to other search algorithms.
 For the implementation of the codes the Linux Mint operating system, the
 C programming language, the GCC compiler was used.
 The GNUPLOT tool was used to create the graphics.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
.
\end_layout

\begin_layout Standard
\align center

\size larger
SUMÁRIO
\end_layout

\begin_layout Description
1 Introdução aos algoritmos de ordenação ............................................
 4
\end_layout

\begin_deeper
\begin_layout Description
1.1 Algoritmoos quadráticos ........................................................
 4
\end_layout

\begin_layout Description
1.2 Algoritmos lineares ................................................................
 4
\end_layout

\begin_layout Description
1.3 Algoritmos logarítmicos .........................................................
 4
\end_layout

\end_deeper
\begin_layout Description
2 Análise dos algoritmos de ordenação...................................................
 4
\end_layout

\begin_deeper
\begin_layout Description
2.1 Insertion sort ..........................................................................
 4
\end_layout

\begin_layout Description
2.2 Merge sort ..............................................................................
 8
\end_layout

\begin_layout Description
2.3 Quick sort ...............................................................................
 11
\end_layout

\begin_layout Description
2.4 Bubble sort .............................................................................
 18
\end_layout

\begin_layout Description
2.5 Couting sort ............................................................................
 20
\end_layout

\begin_layout Description
2.6 Distribution sort ......................................................................
 21
\end_layout

\begin_layout Description
2.7 Bogo sort .................................................................................
 22
\end_layout

\begin_layout Description
2.8 Comparação de desempenho ....................................................
 24
\end_layout

\begin_deeper
\begin_layout Description
2.8.1 Ordem 1 ........................................................................
 24
\end_layout

\begin_layout Description
2.8.2 Ordem 2 ........................................................................
 25
\end_layout

\begin_layout Description
2.8.3 Ordem 3 ........................................................................
 26
\end_layout

\begin_layout Description
2.8.4 Ordem 4 ........................................................................
 27
\end_layout

\end_deeper
\end_deeper
\begin_layout Description
3 Algoritmos de busca .............................................................................
 27
\end_layout

\begin_deeper
\begin_layout Description
3.1 Busca linear ..............................................................................
 28
\end_layout

\begin_layout Description
3.2 Busca binária ............................................................................
 30
\end_layout

\begin_layout Description
3.3 Comparação de desempenho .....................................................
 34
\end_layout

\begin_deeper
\begin_layout Description
3.3.1 Ordem 1 .........................................................................
 35
\end_layout

\begin_layout Description
3.3.2 Ordem 2 .........................................................................
 36
\end_layout

\begin_layout Description
3.3.3 Ordem 3 .........................................................................
 36
\end_layout

\begin_layout Description
3.3.4 Ordem 4 .........................................................................
 37
\end_layout

\end_deeper
\end_deeper
\begin_layout Description
4 Conclusão ..............................................................................................
 38
\begin_inset Newpage newpage
\end_inset

 
\end_layout

\begin_layout Section
Introdução aos algoritmos de ordenação
\end_layout

\begin_layout Standard
Em computação, um algoritmo de ordenação coloca elementos de uma dada sequência
 em uma certa ordem, ou em outras palavras, como o próprio nome diz, efetua
 sua ordenação completa ou parcial, geralmente são utilizadas as ordens
 numérica ou lexicográfica.
 Dado o algoritmo, é possível calcular sua complexidade, assim como seu
 tempo de execução, e, partir de uma análise criteriosa decidir se o mesmo
 é o melhor a ser usado em dada circunstância.
 Geralmente, a complexidade dos algoritmos de ordenação são quadráticos
 ou lineares.
\end_layout

\begin_layout Subsection
Algoritmos quadráticos
\end_layout

\begin_layout Standard
Algoritmos de ordenação com complexidade quadrática são representados por
 
\begin_inset Formula $\varTheta\left(n^{2}\right)$
\end_inset

, isso acontece por conta dos itens de dados serem processados aos pares,
 muitas vezes em uma repetição dentro da outra.
 Por exemplo, dado 
\begin_inset Formula $n$
\end_inset

 igual à mil, o número de operações é da ordem de 1 milhão.
 Algoritmos deste tipo somente são úteis para resolver problemas de tamanhos
 relativamente pequenos.
\end_layout

\begin_layout Subsection
Algoritmos lineares
\end_layout

\begin_layout Standard
Algoritmos de ordenação com complexidade linear são representados por 
\begin_inset Formula $\varTheta(n)$
\end_inset

, ou seja, complexidade algorítmica em que um pequeno trabalho é realizado
 sobre cada elemento da entrada.
 Esta é a melhor situação possível para um algoritmo que tem que processar
 
\begin_inset Formula $n$
\end_inset

 elementos de entrada ou produzir 
\begin_inset Formula $n$
\end_inset

 elementos de saída.
 Cada vez que 
\begin_inset Formula $n$
\end_inset

 dobra de tamanho o tempo de execução dobra.
\end_layout

\begin_layout Subsection
Algoritmos logarítmicos
\end_layout

\begin_layout Standard
Algoritmos de ordenação com complexidade logarítmica são representados por
 
\begin_inset Formula $(logn)$
\end_inset

, ou seja, é uma complexidade algorítmica no qual algoritmo resolve um problema
 transformando-o em partes menores.
 Nestes casos, o tempo de execução pode ser considerado como sendo menor
 do que uma constante grande.
 Por exemplo, quando 
\begin_inset Formula $n$
\end_inset

 é igual a um milhão, 
\begin_inset Formula $log_{2}n$
\end_inset

 é aproximadamente 20.
\end_layout

\begin_layout Section
Análise dos algoritmos de ordenação
\end_layout

\begin_layout Standard
Neste relatório, serão apresentados os algoritmos de ordenação couting sort,
 insertion sort, merge sort, quick sort, distribution sort e bubble sort,
 assim como uma comparação de desempenho entre eles, utilizando a ferramenta
 GNUPLOT para criar os gráficos.
\end_layout

\begin_layout Subsection
Insertion sort
\end_layout

\begin_layout Standard
O insertion sort é um algoritmo de ordenação por inserção que percorre o
 vetor a partir da comparação do seu segundo elemento com o seu anterior
 e conforme avança os elementos mais à esquerda vão ficando ordenados, pois
 nas comparações, busca-se o elemento menor que o de partida, invertendo
 suas posições.
 É um algoritmo de ordem quadrática, com excessão ao seu melhor caso, e,
 por muitos é considerado o melhor algoritmo dessa ordem de classificação.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename codigos_imgs/codigo_insertion.png
	lyxscale 10
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Código em C do algoritmo insertion sort
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Seu melhor caso ocorre quando o vetor já se encontra ordenado, nesse caso
 o algoritmo fará o menor número de comparações, a equação que define seu
 melhor caso é dada por
\begin_inset Formula 
\[
T_{b}\left(n\right)=C_{1}+nC_{2}+\left(n-1\right)C_{3}+\left(n-1\right)C_{4}+\left(n-1\right)C_{6}=
\]

\end_inset


\begin_inset Formula 
\[
C_{1}+nC_{2}+nC_{3}-C_{3}+nC_{4}-C_{4}+nC_{6}-C_{6}=
\]

\end_inset


\begin_inset Formula 
\[
n\left(C_{2}+C_{3}+C_{4}+C_{6}\right)-C_{3}-C_{4}-C_{6}+C_{1}
\]

\end_inset

 lembrando que C representa o custo de tempo referente à linha, como visto
 na figura 1.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename comparacao/insertion_melhor.png
	lyxscale 10
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Gráfico de tempo de execução do insertion sort em seu melhor caso
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Na figura 2 é possível visualizar seu tempo de execução em função do vetor
 de tamanho 
\begin_inset Formula $n$
\end_inset

 que varia entre 1000 e 10000 posições, apesar dos ruídos causados por pequenas
 variações por conta de processos externos, sua complexidade é 
\begin_inset Formula $\Theta\left(n\right)$
\end_inset

, ou seja, linear.
\end_layout

\begin_layout Standard
O caso médio esperado do insertion sort foi calculado de forma que o vetor
 de entrada foi preenchido de forma aleatória, ou seja, o algoritmo poderá
 ou não esta ordenado, variando assim o tempo de execução.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename comparacao/insertion_medio.png
	lyxscale 10
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Gráfico de tempo de execução do insertion sort em seu caso médio
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Na figura 3 é possível visualizar seu tempo de execução em função do vetor
 de tamanho 
\begin_inset Formula $n$
\end_inset

 que varia entre 1000 e 10000 posições, e tem formato de uma parábola, mostrando
 assim claramente que seu caso médio tem complexidade quadrática.
\end_layout

\begin_layout Standard
O pior caso do insertion sort ocorre quando o vetor está ordenado em ordem
 inversa (decrescente), sendo assim, tornando-o de ordem 
\begin_inset Formula $\Theta\left(n^{2}\right)$
\end_inset

, a equação que define sua ordem é dada por
\begin_inset Formula 
\[
T_{w}\left(n\right)=C_{1}+nC_{2}+\left(n-1\right)C_{3}+C_{4}\sum_{i=1}^{n-1}i+C_{5}\sum_{i=1}^{n-1}i+\left(n-1\right)C_{6}+\left(n-1\right)C_{4}=
\]

\end_inset


\begin_inset Formula 
\[
C_{1}+nC_{2}+nC_{3}-C_{3}+C_{4}\left(\frac{n}{2}\left(n+1\right)-n\right)+C_{5}+\left(\frac{n}{2}\left(n+1\right)-n\right)+C_{6}n-C_{6}+C_{4}\left(n-1\right)=
\]

\end_inset


\begin_inset Formula 
\[
C_{1}+nC_{2}+nC_{3}-C_{3}+C_{4}\left(\frac{n^{2}+n}{2}-n\right)+C_{5}\left(\frac{n^{2}+n}{2}-n\right)+C_{6}n-C_{6}+C_{4}\left(n-1\right)=
\]

\end_inset


\begin_inset Formula 
\[
n\left(C_{2}+C_{3}+C_{6}\right)+\left(C_{4}+C_{5}\right)\left(\frac{n^{2}+n-2n}{2}\right)+\left(n-1\right)C_{4}-C_{6}+C_{1}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename comparacao/insertion_pior.png
	lyxscale 10
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Gráfico de tempo de execução do insertion sort em seu pior caso
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Como visto na equação apresentada graficamente na figura 4, assim como o
 caso médio, o pior caso do insertion sort tem complexidade 
\begin_inset Formula $\varTheta\left(n^{2}\right)$
\end_inset

, embora seu tempo de execução seja superior.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename comparacao/comparacao_insertion.png
	lyxscale 10
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Gráfico comparativo entre os casos do insertion sort
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
No gráfico da figura 5 é possível visualizar que todos os casos estão de
 acordo com seu título.
 É válido lembrar que, em comparação ao médio e pior caso, o melhor caso
 tem tempo de execução em segundos muito baixo por ser de ordem linear,
 por isso não é perceptível sua variação.
\end_layout

\begin_layout Subsection
Merge sort
\end_layout

\begin_layout Standard
O algoritmo de ordenação merge sort usa uma técnica de divisão, ou seja,
 reparte o vetor sucessivamente ao meio até que reste apenas um elemento,
 onde a partir daí será ordenado e depois intercalado até chegar ao vetor
 original, porém ordenado.
 Para fazer a implementação deste algorítmo, é necessário ter conhecimento
 do tamanho do vetor, bem como seu valor de inicio e fim, para que seja
 possível dividir o vetor em subvetores.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename codigos_imgs/codigo_merge.png
	lyxscale 20
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Código em C do algoritmo merge sort
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
Esse processamento é possível devido o método de recursão onde o problema
 inicial é divido em sub-problemas, transformando-se em problemas simples
 de serem resolvidos.
 O algoritmo é composto por duas funções, uma para ordenação e outra responsável
 por dividir o vetor em sub-vetores.
 Para obter o tempo de execução do Merge Sort primeiramente é necessário
 ter conhecimento do tempo de execução da função responsável pela divisão
 do vetor.
 Não existe “casos” necessariamente, pois independente da situação dos dados
 no vetor, o algoritmo irá sempre dividir e intercalar os dados.
 Logo, o tempo é dado pela altura da árvore de recursão, ou seja, pela quantidad
e sub-vetores que serão gerados que é dado em 
\begin_inset Formula $\Theta(logn)$
\end_inset

, e pela quantidade de operações em cada nível da árvore (em cada vetor)
 que é dado por 
\begin_inset Formula $\Theta(n)$
\end_inset

.
 De maneira analítica é possível observar que a complexidade do algoritmo
 é 
\begin_inset Formula $\Theta(nlogn)$
\end_inset

.
 É possível também chegar a essa conclusão de forma mais precisa equacionando
 o problema:
\begin_inset Formula 
\[
T^{ms}\left(n\right)=C_{1}+C_{2}+C_{3}+C_{4}+C_{5}+2T^{ms}\left(\frac{n}{2}\right)+T^{m}(n)
\]

\end_inset

 por fins de simplicidadade, considera-se
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
a=C_{1}+C_{2}+C_{3}+C_{4}+C_{5}
\]

\end_inset

como visto, é obtida uma relação de recorrência onde é encerrada quando
 o vetor alcança um valor unitário, ou seja, o algoritmo irá executar somente
 a linha 
\begin_inset Formula $C_{1}$
\end_inset

, sendo assim
\begin_inset Formula 
\[
T\left(1\right)=C_{1}
\]

\end_inset

 prosseguindo com a relação de recorrência
\begin_inset Formula 
\[
T^{ms}\left(\frac{n}{2}\right)=a+2T^{ms}\left(\frac{\frac{n}{2}}{2}\right)+T^{m}\left(\frac{n}{2}\right)=
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
a+2T^{ms}\left(\frac{n}{4}\right)=T^{m}\left(\frac{n}{2}\right)
\]

\end_inset

 então temos que
\begin_inset Formula 
\[
T^{^{ms}}\left(n\right)=a+2\left[a+2T^{ms}\left(\frac{n}{4}\right)+T^{m}\left(\frac{n}{2}\right)\right]+T^{m}\left(n\right)=
\]

\end_inset


\begin_inset Formula 
\[
3a+4T^{ms}\left(\frac{n}{4}\right)+2T^{m}\left(\frac{n}{2}\right)+T^{m}\left(n\right)
\]

\end_inset

 calculando mais uma relação de recorrência, temos
\begin_inset Formula 
\[
T^{ns}\left(\frac{n}{4}\right)=a+2T^{ms}\left(\frac{\frac{n}{4}}{2}\right)+T^{m}\left(\frac{n}{4}\right)
\]

\end_inset

 substituindo os termos, ficamos com
\begin_inset Formula 
\[
3a+4\left[a+2T^{ms}\left(\frac{n}{8}\right)+T^{m}\left(\frac{n}{4}\right)\right]+2T^{m}\left(\frac{n}{2}\right)+T^{m}\left(n\right)=
\]

\end_inset

 
\begin_inset Formula 
\[
7a+8T^{ms}\left(\frac{n}{8}\right)+4T^{m}\left(\frac{n}{4}\right)+2T^{m}\left(\frac{n}{2}\right)+T^{m}\left(n\right)
\]

\end_inset

 a partir deste ponto, já é possível perceber um padrão para a criação da
 fórmula fechada, sendo 
\begin_inset Formula $x$
\end_inset

 a variável que muda em cada relação, então
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
T^{ms}(n)=(2^{x}-1)a+2^{x}T^{ms}\left(\frac{n}{2^{x}}\right)+\sum_{i=0}^{x-1}2^{i}T^{m}\left(\frac{n}{2^{i}}\right)
\]

\end_inset

 para encerrar a relação de recorrência é necessário que o vetor tenha tamanho
 unitário, então
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{n}{2^{x}}=1
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
n=2^{x}
\]

\end_inset


\begin_inset Formula 
\[
log_{2}n=x
\]

\end_inset

 substituindo na equação se obtém
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
T^{ms}(n)=(2^{log_{2}n}-1)a+2^{log_{2}n}T^{ms}\left(\frac{n}{2^{log_{2}n}}\right)+\sum_{i=0}^{log_{2}n-1}2^{i}T^{m}\left(\frac{n}{2^{i}}\right)=
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
T^{ms}(n)=(2^{log_{2}n}-1)a+nT^{ms}\left(1\right)+\sum_{i=0}^{log_{2}n-1}2^{i}T^{m}\left(\frac{n}{2^{i}}\right)
\]

\end_inset

então
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
T^{ms}\left(n\right)=\left(n-1\right)a+nC_{1}+\sum_{i=0}^{log_{2}n-1}2^{i}T^{m}\left(\frac{n}{2^{i}}\right)
\]

\end_inset

 a função 
\begin_inset Formula $T^{m}$
\end_inset

 tem complexidade 
\begin_inset Formula $\Theta\left(n\right)$
\end_inset

, então por simplificação, consideramos no formato 
\begin_inset Formula $bx+c$
\end_inset

, então
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
T^{ms}\left(n\right)=\left(n-1\right)a+nC_{1}+\sum_{i=0}^{log_{2}n-1}2^{i}(b\left(\frac{n}{2^{i}}\right)+c)=
\]

\end_inset

 expandindo se obtém 
\begin_inset Formula 
\[
T^{ms}\left(n\right)=\left(n-1\right)a+nC_{1}+\sum_{i=0}^{log_{2}n-1}2^{i}b\left(\frac{n}{2^{i}}\right)+2^{i}c=
\]

\end_inset

 
\begin_inset Formula 
\[
T^{ms}\left(n\right)=\left(n-1\right)a+nC_{1}+\sum_{i=0}^{log_{2}n-1}(bn+2^{i}c)
\]

\end_inset

 ainda é possível expandir o somatório, entretando, neste ponto já é possível
 observar que a complexidade do algoritmo é 
\begin_inset Formula $nlogn$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename comparacao/merge.png
	lyxscale 10
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Gráfico de tempo de execução do merge sort
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Na figura 7 é possível observar o tempo de execução do algoritmo merge sort
 em função do número de elementos em um vetor 
\begin_inset Formula $n$
\end_inset

 que varia entre 
\begin_inset Formula $1000$
\end_inset

 à 
\begin_inset Formula $10000$
\end_inset

.
 O tempo de execução se asemelha em algo linear, já que é um um logarítimo
 multiplicando 
\begin_inset Formula $n$
\end_inset

.
\end_layout

\begin_layout Subsection
Quick sort
\end_layout

\begin_layout Standard
O Quicksort é considerado algoritmo mais eficiente na ordenação por comparação,
 nele o vetor original vai sendo dividido em dois por meio de um procedimento
 recursivo.
 Essa divisão ocorre até que o vetor fique com apenas um elemento, porém,
 ao contrário do que acontece no merge sort, os elementos que são comparados
 já são colocados de forma ordenada, não tendo assim a necessidade de outra
 função para fazer esse procedimento.
\end_layout

\begin_layout Standard
Para isso é escolhido um elemento do vetor como sendo o primeiro valor a
 ser comparado com os demais, geralmente chamado de pivô.
 Após a partição, todos os elementos a esquerda do pivô são menores e os
 a direita maiores, fazendo com que o pivô já fique na sua posição certa.
 A partir daí começa as comparações do pivô e os elementos do início e do
 fim do vetor.
 O quick sort tem complexidade 
\begin_inset Formula $\Theta\left(n^{2}\right)$
\end_inset

 no pior caso e 
\begin_inset Formula $\Theta\left(nlogn\right)$
\end_inset

 em seu melhor e médio caso.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename codigos_imgs/codigo_quick.png
	lyxscale 10
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Código em C do algoritmo quick sort
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
O melhor caso do algoritmo quick sort ocorre quando o vetor é preenchido
 de tal maneira que o pivô selecionado nas partições realizadas seja o elemento
 médio do vetor auxiliar, fazendo com que o algoritmo seja executado com
 maior rapidez.
 A equação que define a complexidade de seu melhor caso pode ser dada por
\begin_inset Formula 
\[
T_{b}\left(n\right)=C_{1}+C_{2}+C_{3}+C_{4}+C_{5}+2T_{b}\left(\frac{n-1}{2}\right)+T^{p}\left(n\right)
\]

\end_inset

 por fins de praticidade, a partir deste ponto considera-se
\begin_inset Formula 
\[
a=C_{1}+C_{2}+C_{3}+C_{4}+C_{5}
\]

\end_inset

 então
\begin_inset Formula 
\[
T_{b}\left(n\right)=a+2T_{b}\left(\frac{n-1}{2}\right)+T^{p}\left(n\right)
\]

\end_inset

 é possível observar que é obtida uma relação de recorrência, onde para
 se chegar no caso base, o vetor deve ser unitário ou nulo, nesses caso
 somente a linha 
\begin_inset Formula $C_{1}$
\end_inset

 será executada, então
\begin_inset Formula 
\[
T_{b}\left(0\right)=C_{1}
\]

\end_inset


\begin_inset Formula 
\[
T_{b}\left(1\right)=C_{1}
\]

\end_inset

 iniciando a próxima equação da recorrência para tentar reconhecer um padrão
\begin_inset Formula 
\[
T_{b}\left(\frac{n-1}{n}\right)=a+2T_{b}\left(\frac{n-3}{4}\right)+T^{p}\left(\frac{n-1}{2}\right)
\]

\end_inset

 substituindo na equação original
\begin_inset Formula 
\[
T_{b}\left(n\right)=a+2\left[a+2T_{b}\left(\frac{n-3}{4}\right)+T^{p}\left(\frac{n-1}{2}\right)\right]+T^{p}\left(n\right)=
\]

\end_inset


\begin_inset Formula 
\[
3a+4T_{b}\left(\frac{n-3}{4}\right)+2T^{p}\left(\frac{n-2}{2}\right)+T^{p}\left(n\right)
\]

\end_inset

 iniciando a pŕoxima equação da recorrência
\begin_inset Formula 
\[
T_{b}\left(\frac{n-3}{4}\right)=a+2T_{b}\left(\frac{\frac{n-3}{n}-1}{2}\right)+T^{p}\left(\frac{n-3}{4}\right)
\]

\end_inset

 substituindo na equação original
\begin_inset Formula 
\[
T_{b}\left(n\right)=3a+4\left[a+2T_{b}\left(\frac{n-7}{8}\right)+T^{p}\left(\frac{n-3}{4}\right)\right]+2T^{p}\left(\frac{n-1}{2}\right)+T^{p}\left(n\right)=
\]

\end_inset


\begin_inset Formula 
\[
7a+8T_{b}\left(\frac{n-7}{8}\right)+4T^{p}\left(\frac{n-3}{4}\right)+2T^{p}\left(\frac{n-1}{2}\right)+T^{p}\left(n\right)
\]

\end_inset

 neste ponto já é possível observar o padrão da recorrência, definindo que
 
\begin_inset Formula $x$
\end_inset

 substituirá os valores que variam, se tem
\begin_inset Formula 
\[
T_{b}\left(n\right)=\left(2^{x}-1\right)a+2^{x}T_{b}\left(\frac{n-\left(2^{x}-1\right)}{2^{x}}\right)+\sum_{i=0}^{x-1}2^{i}T^{p}\left(\frac{n-\left(2^{i}-1\right)}{2^{i}}\right)
\]

\end_inset

 neste ponto é necessário igualar a variante igualar o termo 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $T_{b}\left(\frac{n-\left(2^{x}-1\right)}{2}\right)=1$
\end_inset

 para descobir o valor de 
\begin_inset Formula $x$
\end_inset

 que encerra essa recorrência, então
\begin_inset Formula 
\[
\frac{n-\left(2^{x}-1\right)}{2^{x}}=1
\]

\end_inset

fazendo um processo de isolamento se obtém
\begin_inset Formula 
\[
x=log_{2}\left(n+1\right)-1
\]

\end_inset

substituindo na equação, se tem
\begin_inset Formula 
\[
\left(\frac{n+1}{2}-1\right)a+\frac{n+1}{2}T_{b}\left(\frac{n-\left(\frac{n+1}{2}-1\right)}{\frac{n+1}{2}}\right)+\sum_{i=0}^{log_{2}(n+1)-2}2^{i}T^{p}\left(\frac{n-\left(2^{i}-1\right)}{2^{i}}\right)=
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\left(\frac{n-1}{2}\right)a+\left(\frac{n+1}{2}\right)T_{b}\left(1\right)+\sum_{i=0}^{log_{2}(n+1)-2}2^{i}T^{p}\left(\frac{n-\left(2^{i}-1\right)}{2^{i}}\right)=
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\left(\frac{n-1}{2}\right)a+\left(\frac{n+1}{2}\right)C_{1}+\sum_{i=0}^{log_{2}(n+1)-2}2^{i}T^{p}\left(\frac{n-\left(2^{i}-1\right)}{2^{i}}\right)
\]

\end_inset

 agora tratando a outra recorrência, sabe-se que a função 
\begin_inset Formula $T^{p}$
\end_inset

 é linear, ou seja, tem o formato 
\begin_inset Formula $ax+b$
\end_inset

, então, pode-se considerar
\begin_inset Formula 
\[
2^{i}T^{p}\left(\frac{n-\left(2^{i}-1\right)}{2^{i}}\right)=2^{i}k\left(\frac{n-\left(2^{i}-1\right)}{2^{i}}\right)+y
\]

\end_inset

 substituindo se tem
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
T_{b}\left(n\right)=\left(\frac{n-1}{2}\right)a+\left(\frac{n+1}{2}\right)C_{1}+\sum_{i=0}^{log_{2}(n+1)-2}2^{i}\left(k\left(\frac{n-\left(2^{i}-1\right)}{2^{i}}\right)+y\right)=
\]

\end_inset


\begin_inset Formula 
\[
T_{b}\left(n\right)=\left(\frac{n-1}{2}\right)a+\left(\frac{n+1}{2}\right)C_{1}+\sum_{i=0}^{log_{2}(n+1)-2}\left(2^{i}k\left(\frac{n-\left(2^{i}-1\right)}{2^{i}}\right)+2^{i}y\right)=
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
T_{b}\left(n\right)=\left(\frac{n-1}{2}\right)a+\left(\frac{n+1}{2}\right)C_{1}+\sum_{i=0}^{log_{2}(n+1)-2}\left(2^{i}k\left(\frac{n+1}{2^{i}}-1\right)+2^{i}y\right)=
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
T_{b}\left(n\right)=\left(\frac{n-1}{2}\right)a+\left(\frac{n+1}{2}\right)C_{1}+\sum_{i=0}^{log_{2}(n+1)-2}\left(k\left(n+1\right)-2^{i}k\right)+2^{i}y
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename comparacao/quick_melhor.png
	lyxscale 10
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Gráfico de tempo de execução do melhor caso do algoritmo quick sort em seu
 melhor caso
\end_layout

\end_inset


\end_layout

\end_inset

 na figura 9 é possível visualizar graficamente o tempo de execução do algoritmo
 quick sort em seu melhor caso em função de um vetor variando entre 1000
 e 10000 elementos.
\end_layout

\begin_layout Standard
O pior caso do algoritmo quick sort se dá quando o vetor está ordenado de
 forma crescente, já que o pivô escolhido é o último elemento, irá criar
 vetores auxiliares de tamanhos 
\begin_inset Formula $n-1$
\end_inset

 e 
\begin_inset Formula $0$
\end_inset

, fazendo com que as comparações sejam feitas para todas as posições do
 vetor.
 Se o pivô é muito próximo de um lado da sequência, ou seja, o primeiro,
 então o tempo de execução é alto, pois a primeira partição exige 
\begin_inset Formula $n-1$
\end_inset

 comparações e apenas rearranja o pivô.
 A equação que define o pior caso se da por 
\begin_inset Formula 
\[
T_{w}\left(n\right)=2C_{1}+C_{2}+C_{3}+C_{4}+C_{5}+T_{w}\left(n-1\right)+T^{p}\left(n\right)
\]

\end_inset

 por fins de praticidade, será considerado
\begin_inset Formula 
\[
a=2C_{1}+C_{2}+C_{3}+C_{4}
\]

\end_inset

 portanto,
\begin_inset Formula 
\[
T_{w}\left(n\right)=a+T_{w}\left(n-1\right)+T^{p}\left(n\right)
\]

\end_inset

 é possível observar que é obtida uma relação de recorrência, onde para
 se chegar no caso base, o vetor deve ser unitário ou nulo, nesses caso
 somente a linha 
\begin_inset Formula $C_{1}$
\end_inset

 será executada, então
\begin_inset Formula 
\[
T_{b}\left(0\right)=C_{1}
\]

\end_inset


\begin_inset Formula 
\[
T_{b}\left(1\right)=C_{1}
\]

\end_inset

 iniciando a próxima equação da recorrência, se tem
\begin_inset Formula 
\[
T_{w}\left(n-1\right)=a+T_{w}\left(n-2\right)+T^{p}\left(n-1\right)
\]

\end_inset

 substituindo na equação original se tem
\begin_inset Formula 
\[
T_{w}\left(n\right)=a+\left[a+T_{w}\left(n-2\right)+T^{p}\left(n-1\right)\right]T^{p}\left(n\right)=
\]

\end_inset


\begin_inset Formula 
\[
2a+T_{w}\left(n-2\right)+T^{p}\left(n\right)+T^{p}\left(n-1\right)
\]

\end_inset

 iniciando a próxima equação da recorrência, se tem
\begin_inset Formula 
\[
T_{w}\left(n-2\right)=a+T_{w}\left(n-3\right)+T^{p}\left(n-2\right)
\]

\end_inset

 substituindo na equação original, se tem
\begin_inset Formula 
\[
2a+\left[a+T_{w}\left(n-3\right)+T^{p}\left(n-2\right)\right]+T^{p}\left(n\right)+T^{p}\left(n-1\right)=
\]

\end_inset


\begin_inset Formula 
\[
3a+T_{w}\left(n-3\right)+\sum_{i=0}^{n-2}T^{p}\left(n-i\right)=
\]

\end_inset


\begin_inset Formula 
\[
\left(n-1\right)a+T_{w}\left(1\right)+\sum_{i=0}^{n-2}z\left(n-i\right)+y=
\]

\end_inset


\begin_inset Formula 
\[
n-a-a+C_{1}+\left(n-1\right)y+z\sum_{i=2}^{n}i=
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
n\left(a+y\right)-y-a+C_{1}+z\left(\frac{n}{2}\left(n+1\right)-1\right)=
\]

\end_inset


\begin_inset Formula 
\[
n\left(a+y\right)-y+a+C_{1}-z+z\frac{n}{2}\left(n+1\right)=
\]

\end_inset


\begin_inset Formula 
\[
n\left(a+y+\frac{3}{z}\right)-y-a+C_{1}-z+\frac{zn^{2}}{2}=
\]

\end_inset


\begin_inset Formula 
\[
\frac{zn^{2}}{2}+\left(a+y+\frac{z}{2}\right)n+C_{1}-y-a-z
\]

\end_inset

 neste ponto já é possível observar que o pior caso do algoritmo quick sort
 conta com termos quadráticos, ou seja, sua complexidade é 
\begin_inset Formula $\Theta\left(n^{2}\right)$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename comparacao/quick_pior.png
	lyxscale 10
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Gráfico de tempo de execução do algoritmo quick sort em seu pior caso
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset

 na figura 10 vemos a parábola formada pelo tempo de execução do quick sort
 em função de um vetor que varia entre 1000 e 10000 posições.
\end_layout

\begin_layout Standard
Para analisar seu caso médio esperado foi preenchido o vetor de forma aleatória,
 mantendo o pivô como o último elemento, sua complexidade assim como o melhor
 caso se dá por 
\begin_inset Formula $\Theta\left(nlogn\right)$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename comparacao/quick_medio.png
	lyxscale 10
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Gráfico de tempo de execução do algoritmo quick sort em seu caso médio
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Na figura 12 é possível analisar todos os casos do quick sort graficamente,
 entretando, em comparação ao melhor e médio caso o pior caso tem um tempo
 de execução muito maior, por se tratar de um algorítmo quadrático.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename comparacao/comparacao_quick.png
	lyxscale 10
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Gráfico comparativo entre os casos do quick sort
\end_layout

\end_inset


\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
Na figura 13 é possível visualizar de forma mais clara a comparação entre
 o caso médio e melhor caso do quick sort.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename comparacao/quick_melhor_medio.png
	lyxscale 10
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Gráfico comparativo entre o melhor e médio caso do quick sort
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Bubble sort 
\end_layout

\begin_layout Standard
O algoritmo bubble sort é um dos mais simples dos algoritmos de ordenação,
 a ideia é percorrer o vetor diversas vezes, verificando a cada passagem
 se o proximo elemento do vetor é ou não maior com o qual está sendo comparado,
 caso for, fazer a troca.
 Sua complexidade em geral é 
\begin_inset Formula $\Theta\left(n^{2}\right)$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename codigos_imgs/codigo_bubble.png
	lyxscale 10
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Código em C do algoritmo bubble sort
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\xout off
\uuline off
\uwave off
\noun off
\color none
É possível equacionar a complexidade o bubble sort da seguinte maneira
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
T_{w}\left(n\right)=C_{1}+\left(n+1\right)C_{2}+n\left(n+1\right)C_{3}+n^{2}C_{4}+(\frac{n^{2}-n}{2})C_{5,6,7}=
\]

\end_inset


\begin_inset Formula 
\[
C_{1}+nC_{2}+C_{2}+nC_{3}+n^{2}C_{3}+n^{2}C_{4}+(\frac{n^{2}-n}{2})C_{5,6,7}=
\]

\end_inset


\begin_inset Formula 
\[
n^{2}\left(C_{3}+C_{4}\right)+(\frac{n^{2}-n}{2})C_{5,6,7}+n\left(C_{2}+C_{3}\right)+C_{1}+C_{2}
\]

\end_inset

 é interessante notar como claramente a equação toma forma de algo quadrático
 
\begin_inset Formula $ax^{2}+bx+c$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename comparacao/bubble.png
	lyxscale 10
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Gráfico de tempo de execução do melhor caso do algoritmo bubble sort em
 seu pior caso
\end_layout

\end_inset


\end_layout

\end_inset

 Na figura 15 é possível visualizar graficamente que seu tempo de execução
 em função de um vetor tamanho variando entre 1000 e 10000 posições é 
\begin_inset Formula $\Theta\left(n^{2}\right)$
\end_inset

.
 É possível fazer uma pequena alteração no bubble sort para que o mesmo
 tenha ordem linear quando o vetor já estiver ordenado, para isso adiciona-se
 uma linha para verificar se houve alguma troca na primeira execução do
 laço interno, caso não tenha, significa que o vetor já está ordenado, podendo
 assim encerrar a execução.
\end_layout

\begin_layout Subsection
Couting sort 
\end_layout

\begin_layout Standard
O couting sort é um algoritmo de ordenação estável não baseado em troca
 de posições, e sim em contagem de posições e realocamento, sua complexidade
 é 
\begin_inset Formula $\Theta\left(n^{2}\right)$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename codigos_imgs/codigo_couting.png
	lyxscale 10
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Código em C do algoritmo couting sort 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
a função new_0 chamada no algoritmo da figura 16 tem como finalidade preencher
 um vetor auxiliar com zeros.
 A equação que define a complexidade do couting sort, que não tem melhor
 e pior caso definido, pode ser dada por
\begin_inset Formula 
\[
T\left(n\right)=C_{1}+C_{2}+\left(n+1\right)C_{3}+n\left(n+1\right)C_{4}+n^{2}C_{5}+\left(\frac{n^{2}-n}{2}\right)C_{6}+\left(n+1\right)C_{7}+nC_{8}+C_{9}=
\]

\end_inset


\begin_inset Formula 
\[
C_{1}+C_{2}+nC_{3}+C_{3}+(n^{2}+n)C_{4}+n^{2}C_{5}+\frac{C_{6}}{2}n\left(n-1\right)+C_{7}+nC_{7}+nC_{8}+C_{9}=
\]

\end_inset


\begin_inset Formula 
\[
C_{1}+C_{2}+nC_{3}+C_{3}+n^{2}C_{4}+nC_{4}+n^{2}C_{5}+\frac{C_{6}}{2}n\left(n-1\right)+C_{7}+nC_{7}+nC_{8}+C_{9}=
\]

\end_inset


\begin_inset Formula 
\[
n^{2}\left(C_{4}+C_{5}\right)+n\left(C_{3}+C_{4}+C_{7}+C_{8}+\frac{C_{6}}{2}\left(n-1\right)\right)+C_{1}+C_{2}+C_{3}+C_{7}+C_{9}
\]

\end_inset

 como visto, o maior termo é quadrático, confirmando assim sua complexidade
 
\begin_inset Formula $\Theta\left(n^{2}\right)$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename comparacao/couting.png
	lyxscale 10
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Gráfico de tempo de execução do couting sort
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
na figura 17 é possível visualizar o tempo de execução do algorítmo em função
 de vetores com tamanho entre 1000 e 10000.
\end_layout

\begin_layout Subsection
Distribution sort
\end_layout

\begin_layout Standard
O distribution sort é um dos, se não o, algoritmo de ordenação mais rápido,
 sendo de ordem estável 
\begin_inset Formula $\Theta\left(n+k\right)$
\end_inset

, entretanto, sua execução requer grande uso de memória em determinados
 casos por criar vetores auxiliares com grande tamanho.
 Utiliza uma técnica de encontrar o maior e o menor elemento presente no
 vetor, e então encontrar sua real posição através da criação e manipulação
 de vetores auxiliares (por isso o grande gasto de memória).
 Seu tempo de execução depende tanto do tamanho do vetor, quanto do vetor
 auxiliar, que vai ser de tamanho do maior elemento menos o tamanho do menor
 elemento.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename codigos_imgs/codigo_distribution.png
	lyxscale 10
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Código em C do algoritmo distribution sort 
\end_layout

\end_inset


\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
Para entender melhor a equação da complexidade do distribution sort, consideremo
s
\begin_inset Formula 
\[
a=C_{1}+C_{2}+C_{3}+C_{4}+C_{5}+C_{6}
\]

\end_inset

 e
\begin_inset Formula 
\[
k=x-y
\]

\end_inset

 sendo 
\begin_inset Formula $x$
\end_inset

 o maior elemento presente no vetor e 
\begin_inset Formula $y$
\end_inset

 o menor elemento.
 Então temos
\begin_inset Formula 
\[
T\left(n\right)=a+\left(n+1\right)C_{7}+nC_{8}+\left(k+1\right)C_{9}+kC_{10}+\left(n+1\right)C_{11}+n\left(C_{12}+C_{13}+C_{14}\right)=
\]

\end_inset


\begin_inset Formula 
\[
a+nC_{7}+C_{7}+nC_{8}+kC_{9}+C_{9}+kC_{10}+nC_{11}+C_{11}+n\left(C_{12}+C_{13}+C_{14}\right)=
\]

\end_inset


\begin_inset Formula 
\[
k\left(C_{9}+C_{10}\right)+n\left(C_{7}+C_{8}+C_{11}+C_{12}+C_{13}+C_{14}\right)+C_{7}+C_{9}+C_{11}+a
\]

\end_inset

 e podemos observar que é provada sua ordem, que embora seja linear, depende
 não somente de 
\begin_inset Formula $n$
\end_inset

.
 A grande desvantagem do distribution sort é que o uso de memória gasto
 cresce em função de 
\begin_inset Formula $k$
\end_inset

.
 A figura 19 mostra seu tempo de execução em função de um vetor que varia
 entre 1000 e 10000 posições.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename comparacao/distribution.png
	lyxscale 10
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Gráfico de tempo de execução do distribution sort
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
(Extra) Bogo sort
\end_layout

\begin_layout Standard
O bogo sort é um algoritmo não estável de ordenação ineficiente que se baseia
 em reordenação aleatória de elementos.
 A complexidade esperada deste algoritmo é 
\begin_inset Formula $O\left(nxn!\right)$
\end_inset

 e seu tempo de execução esperado depende da quantidade de operações realizadas
 até que o vetor esteja ordenado.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename codigos_imgs/codigo_bogo.png
	lyxscale 10
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Código em C do algoritmo bogo sort
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Este algoritmo depende da sorte e acaso para ordenar o vetor, entretanto
 é possível ter noção da probabilidade de do vetor gerado já está ordenado.
 Para isso, considera-se que a probabilidade de uma dada ordenação qualquer
 gerada aleatoriamente ser correta é de 
\begin_inset Formula $\frac{1}{n!}$
\end_inset

 (desprezando a multiplicação por 
\begin_inset Formula $n$
\end_inset

), então, sendo 
\begin_inset Formula $n$
\end_inset

 o tamanho do vetor, se obtém as seguintes probabilidades
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="15" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $n$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $n!$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Probabilidade do vetor está ordenado
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $1$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $1$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $100\%$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $2$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $2$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $50\%$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $3$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $6$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $16,66\%$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $4$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $24$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $4,16\%$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $5$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $120$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $0,83\%$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $6$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $720$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $0,138\%$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $7$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $5040$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $0,01984126\%$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $8$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $40320$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $0,00248015\%$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $9$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $362880$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $0,00027557\%$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $10$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $3628800$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $0,00002755\%$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $15$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $1307674368000$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $0,000000000007647\%$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $20$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $2432902008176640000$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $0,000000000000000000411\%$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $25$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $15511210043330985984000000$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $0,00000000000000000000000006447\%$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $30$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $2,6\left(10^{32}\right)$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $0,000000000000000000000000000000003699\%$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
Observa-se que a probabilidade de a sorte e o acaso escolher a ordenação
 correta piora muito rapidamente cada vez que um elemento é adicionado.
 A figura 21 mostra o tempo de execução do algoritmo em função de um vetor
 que varia entre 3 e 13 posições.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename comparacao/bogo.png
	lyxscale 10
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Gráfico de tempo de execução do algoritmo bogo sort
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Para se ter uma base, uma máquina capaz de embaralhar e testar a ordenação
 de um vetor um bilhão de vezes por segundo demoraria cerca de 
\begin_inset Formula $245,7$
\end_inset

 milhões de anos para ordenar o vetor (considerando que uma mesma ordenação
 não é sorteada duas vezes), enquanto um vetor de 30 posições demoraria
 cerca de 
\begin_inset Formula $4,2$
\end_inset

 quadrilhões de anos para ser ordenado.
\end_layout

\begin_layout Subsection
Comparação de desempenho 
\end_layout

\begin_layout Standard
O quick sort é considerado por muitos o melhor algoritmo de ordenação, entretand
o, existem casos e casos, em determinadas circustâncias possa ser que outro
 algoritmo traga resultados mais satisfatórios.
 Essa seção tratará de comparar as complexidades dos algoritmos e mostrar
 qual é o melhor dada a circunstância.
\end_layout

\begin_layout Standard
Para a comparação ser justa, todos algorítmos quadráticos serão comparados
 na ordem 1; na ordem 2 será feita uma comparação entre os casos médios
 dos algoritmos, aqueles que não tem caso médio definido também entrarão
 nessa lista; na ordem 3 serão comparados os algoritmos logarítmicos e lineares,
 e na ordem 4 serão mostrados todos algoritmos com todos seus casos.
\end_layout

\begin_layout Subsubsection
Ordem 1
\end_layout

\begin_layout Standard
Iniciando com um gráfico com todos tempos de execução 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename comparacao/quadraticos/todos_quadraticos.png
	lyxscale 10
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Gráfico de tempo de execução dos algoritmos de ordem quadrática
\end_layout

\end_inset


\end_layout

\end_inset

 Vemos que, de todos os algoritimos quadráticos mostrados neste trabalho,
 o insertion em seu caso médio é o que possui menor tempo de execução, e
 até mesmo em seu pior caso tem tempo de execução inferior aos outros algoritmos
 mostrados.
 O couting sort é o algoritmo com maior tempo de execução, consequentemente
 pode-se considerá-lo o pior dessa ordem, e, tendo como base que a ordem
 quadrática é a com maior tempo de execução dentre as demais, pode-se dizer
 que é o pior algorítmo mostrado nesse trabalho, inclusive pior que o bubble
 sort, que vem logo atrás.
 O quick sort em seu pior caso é o meio termo deste gráfico.
\end_layout

\begin_layout Subsubsection
Ordem 2
\end_layout

\begin_layout Standard
Iniciando com um gráfico com todos os tempos de execução
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename comparacao/medios/todos_medios.png
	lyxscale 10
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Gráfico de tempo de execução dos algoritmos em seu caso médio/que não tem
 caso definido
\end_layout

\end_inset


\end_layout

\end_inset

 Embora seja o melhor dos algoritmos de ordem quadrática, o insertion sort
 tem tempo de execução muito superior comparado a outros algoritmos de ordem
 
\begin_inset Formula $n$
\end_inset

 e 
\begin_inset Formula $nlogn$
\end_inset

, desfigurando o gráfico.
\end_layout

\begin_layout Subsubsection
Ordem 3
\end_layout

\begin_layout Standard
Iniciando com um gráfico com os tempos de execução se tem
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename comparacao/medios/lineares.png
	lyxscale 10
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Gráfico de tempo de execução dos algoritmos lineares
\end_layout

\end_inset


\end_layout

\end_inset

 E, toma-se como conclusão, como dito anteriormente neste artigo que o distribut
ion sort é o algoritmo mais rápido dentre os apresentados, inclusive que
 o quick sort em seu melhor caso, entretando ressalva-se que seu grande
 uso de memória pode torná-lo perigoso de se usar.
 O merge sort tem o posto de pior algoritmo entre os com ordem linear.
 Em casos especiais em que o gasto de memória não será um problema o algoritmo
 distribution sort é o mais recomendado, nos demais casos, o quick sort
 tem melhor eficiência.
 
\end_layout

\begin_layout Subsubsection
Ordem 4
\end_layout

\begin_layout Standard
A seguir temos o gráfico com todos os tempos de execução dos algoritmos
 mostrados neste trabalho
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename comparacao/todos_ordenacao.png
	lyxscale 10
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Gráfico de tempo de execução de todos algoritmos apresentados neste trabalho
\end_layout

\end_inset


\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
Como mencionado anteriormente, o couting sort é o algoritmo com maior tempo
 de execução apresentado neste trabalho.
 Na figura 25, é possível visualizar a diferença de tempo de execução dos
 algoritmos de ordem quadrática para aqueles que tem ordem linear que parecem
 ser constantes.
 Embora não de para distinguir bem no gráfico da figura 25, já foi provado
 anteriormente também que, dentre os algoritmos apresentados o distribution
 sort é aquele que tem menor tempo de execução seguido do quick sort no
 caso médio.
\end_layout

\begin_layout Section
Algoritmos de busca
\end_layout

\begin_layout Standard
Algoritmos de busca em termos gerais é um algoritmo que toma um problema
 como entrada e retorna a solução para o problema, geralmente após resolver
 um número possível de soluções.
 Nesta seção será apresentados e comparados dois algoritmos, sendo um de
 busca linear e outro de busca binária.
\end_layout

\begin_layout Subsection
Busca linear
\end_layout

\begin_layout Standard
Chama-se busca linear aquela que percorre um vetor de forma sequencial até
 encontrar o valor especificado, portanto o tempo de execução cresce em
 proporção ao número de elementos no vetor sendo assim um algoritmo linear
 
\begin_inset Formula $n$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename codigos_imgs/codigo_busca_linear.png
	lyxscale 10
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Código em C do algoritmo busca linear
\end_layout

\end_inset


\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
Seu melhor caso ocorre quando o algoritmo encontra o elemento especificado
 na primeira verificação, tornando a função constante independente do tamanho
 do vetor, logo a equação que o define é dada por
\begin_inset Formula 
\[
T\left(n\right)=C_{1}+C_{2}+C_{3}+C_{4}
\]

\end_inset

 embora a ordem seja constante, o tempo de execução varia muito por conta
 da interferência de outros processos externos rodando na máquina, como
 é visto na figura 27.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename comparacao/busca_linear_melhor.png
	lyxscale 10
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Gráfico de tempo de execução da busca linear em seu melhor caso 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
O pior caso da busca linear ocorre quando o elemento à ser procurado não
 está presente no vetor, assim, sua complexidade é igual a 
\begin_inset Formula $n$
\end_inset

 e pode ser equacionada como
\begin_inset Formula 
\[
T\left(n\right)=C_{1}+\left(n+1\right)C_{2}+nC_{3}+C_{5}=
\]

\end_inset


\begin_inset Formula 
\[
n\left(C_{2}+C_{3}\right)+C_{1}+C_{2}+C_{5}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename comparacao/busca_linear_pior.png
	lyxscale 10
	scale 50

\end_inset

 
\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Gráfico de tempo de execução da busca linear em seu pior caso 
\end_layout

\end_inset


\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
O gráfico da figura 28 mostra seu tempo de execução em função de um vetor
 que varia entre dez mil e cem mil posições.
\end_layout

\begin_layout Standard
Para o caso médio esperado do algoritmo de busca linear o vetor foi preenchido
 de forma aleatória, desta maneira o elemento pode estar em qualquer posição
 do vetor, variando o tempo de execução.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename comparacao/busca_linear_medio.png
	lyxscale 10
	scale 50

\end_inset

 
\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Gráfico de tempo de execução da busca linear em seu caso médio esperado
 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
A figura 30 mostra a comparação entre os casos da busca linear.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename comparacao/comparacao_busca_linear.png
	lyxscale 10
	scale 50

\end_inset

 
\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Comparação entre os casos do algoritmo busca linear 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Busca binária
\end_layout

\begin_layout Standard
Chama-se busca binária o algoritmo de busca que segue o paradigma de divisão
 e conquista de ordem logarítmica 
\begin_inset Formula $log$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename codigos_imgs/codigo_busca_binaria.png
	lyxscale 10
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Código em C do algoritmo busca binária
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Assim como a busca linear seu melhor caso ocorre quando o elemento buscado
 é encontrado na primeira comparação, nesse caso, é possível equacionar
 a complexidade como
\begin_inset Formula 
\[
T_{b}\left(n\right)=C_{1}+C_{2}+C_{3}+C_{4}
\]

\end_inset

embora a ordem seja constante, o tempo de execução varia muito por conta
 da interferência de outros processos externos rodando na máquina, como
 é visto na figura 32.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename comparacao/busca_binaria_melhor.png
	lyxscale 10
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Gráfico de tempo de execução da busca binária em seu melhor caso 
\end_layout

\end_inset


\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
O pior caso da busca binária, assim como a linear, ocorre quando o elemento
 à ser procurado não está presente no vetor, assim, sua ordem é logarítmica
 e pode ser equacionada como
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
T_{w}\left(n\right)=C_{1}+C_{2}+C_{3}+C_{5,6,7,8}+T_{w}\left(\frac{n-1}{2}\right)
\]

\end_inset

 percebe-se que é encontrada uma relação de recorrência, que tem como caso
 base um vetor com 0 posições, neste se tem
\begin_inset Formula 
\[
T_{w}\left(0\right)=C_{1}+C_{2}+C_{9}+C_{10}
\]

\end_inset

 por praticidade, será considerado
\begin_inset Formula 
\[
a=C_{1}+C_{2}+C_{3}+C_{5,6,7,8}
\]

\end_inset

 então temos
\begin_inset Formula 
\[
T_{w}\left(n\right)=a+T_{w}\left(\frac{n-1}{2}\right)
\]

\end_inset

 calculando a próxima recorrência se tem
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
T_{w}\left(\frac{n-1}{2}\right)=a+T_{w}\left(\frac{n-3}{4}\right)
\]

\end_inset

 substituindo na equação original
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
T_{w}\left(n\right)=a+\left[a+T_{w}\left(\frac{n-3}{4}\right)\right]=
\]

\end_inset


\begin_inset Formula 
\[
2a+T_{w}\left(\frac{n-3}{4}\right)
\]

\end_inset

 calculando a próxima relação se obtém
\begin_inset Formula 
\[
T_{w}\left(\frac{n-3}{4}\right)=a+T_{w}\left(\frac{\frac{n-3}{4}}{2}-1\right)=
\]

\end_inset


\begin_inset Formula 
\[
a+T_{w}\left(\frac{n-7}{8}\right)
\]

\end_inset

 substituindo na equação original
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
T_{w}\left(n\right)=a+\left[a+\left[a+T_{w}\left(\frac{n-7}{8}\right)\right]\right]=
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
3a+T_{w}\left(\frac{n-7}{8}\right)
\]

\end_inset

 neste ponto já é possível encontrar uma padrão nas trocas, então será utilizado
 a variável 
\begin_inset Formula $x$
\end_inset

 para representá-las
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\left(x\right)a+T_{w}\left(\frac{n-2^{x}-1}{2^{x}}\right)
\]

\end_inset

 agora é necessário encontrar o valor de 
\begin_inset Formula $x$
\end_inset

 que zere a equação para dar fim a recorrência, então
\begin_inset Formula 
\[
\frac{n-(2^{x}-1)}{2^{x}}=0
\]

\end_inset


\begin_inset Formula 
\[
n-2^{x}+1=0
\]

\end_inset


\begin_inset Formula 
\[
n+1=2^{x}
\]

\end_inset


\begin_inset Formula 
\[
log_{2}(n+1)=log_{2}2^{^{x}}
\]

\end_inset


\begin_inset Formula 
\[
x=log_{2}(n+1)
\]

\end_inset

 substituindo na equação original
\begin_inset Formula 
\[
T_{w}\left(n\right)=log_{2}(n+1)a+C_{1}+C_{2}+C_{9}+C_{10}
\]

\end_inset

sendo assim provada que sua ordem é logarítimca, o gráfico que mostra o
 tempo de execução do algoritmo pode ser visto na figura 33.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename comparacao/busca_binaria_pior.png
	lyxscale 10
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Gráfico de tempo de execução da busca binária em seu pior caso 
\end_layout

\end_inset


\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
O caso médio esperado do tempo de execução do algoritmo de busca binária
 foi calculado fazendo com que o elemento a ser procurado no vetor seja
 um número aleatório, presente no mesmo.
 O gráfico que mostra o tempo de execução neste caso pode ser visto na figura
 34.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename comparacao/busca_binaria_medio.png
	lyxscale 10
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Gráfico de tempo de execução da busca binária em seu caso médio
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
O gráfico da figura 35 mostra a comparação entre os casos do algoritmo de
 busca binária.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename comparacao/comparacao_busca_binaria.png
	lyxscale 10
	scale 50

\end_inset

 
\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Comparação entre os casos do algoritmo busca linear 
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Comparação de desempenho
\end_layout

\begin_layout Standard
Como visto nas seções anteriores sabe-se que a complexidade da busca linear
 é 
\begin_inset Formula $n$
\end_inset

 enquanto a da busca binária é 
\begin_inset Formula $logn$
\end_inset

.
 Aqui serão mostrados gráficos comparativos entre os casos dos algoritmos.
 Na ordem 1 será comparado o melhor caso de ambos; na ordem 2 será comparado
 o caso médio de ambos; na ordem 3 será comparado o pior caso de ambos,
 e por fim, na ordem 4 será apresentado um gráfico com ambos os algoritmos
 e todos seus casos.
\end_layout

\begin_layout Subsubsection
Ordem 1
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename comparacao/busca/comparacao_melhor.png
	lyxscale 10
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Gráfico de tempo de execução dos algoritmos em seu melhor caso
\end_layout

\end_inset


\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
É possível visualizar na figura 36 que a busca linear em seu melhor caso
 leva vantagem sobre a busca binária em seu melhor caso, isso ocorre por
 conta que a quantidade de verificações é menor na busca linear.
\end_layout

\begin_layout Subsubsection
Ordem 2
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename comparacao/busca/comparacao_medio.png
	lyxscale 10
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Gráfico de tempo de execução dos algoritmos em seu caso médio
\end_layout

\end_inset


\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
Ao contrário do melhor caso que é basicamente constante, o caso médio dos
 algoritmos já adquire sua ordem, ou seja, 
\begin_inset Formula $n$
\end_inset

 para linear e 
\begin_inset Formula $logn$
\end_inset

 para logarítmica.
 O gráfico da figura 37 mostra a grande vantagem que a busca logarítmica
 leva sobre a linear em relação à tempo de execução.
\end_layout

\begin_layout Subsubsection
Ordem 3
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename comparacao/busca/comparacao_pior.png
	lyxscale 10
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Gráfico de tempo de execução dos algoritmos em seu pior caso
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Assim como no caso médio, o pior caso da busca binária tem tempo de execução
 muito inferior à busca linear.
\end_layout

\begin_layout Subsubsection
Ordem 4
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename comparacao/busca/todos_busca.png
	lyxscale 10
	scale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Gráfico de tempo de execução de todos os casos de ambos algoritmos de busca
\end_layout

\end_inset


\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
Na figura 39 é confirmado que o pior caso da busca linear é com o maior
 tempo de execução seguido do caso médio da mesma.
 Bem distante desses tempos de exeução estão os casos do algoritmo busca
 binária e o melhor caso da busca linear.
 Já foi visto anteriormente que o melhor caso da busca linear é o com menor
 tempo de execução dentre os demais.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Conclusão
\end_layout

\begin_layout Standard
Com as informações coletadas durante o desenvolvimento deste trabalho é
 possível determinar qual o melhor algoritmo dada daterminada situação.
\end_layout

\begin_layout Standard
Dentre os algoritmos de ordenação apresentados, o couting sort é o com maior
 tempo de execução e também necessita de um extra de memória para criar
 um vetor auxiliar então pode ser considerado o pior dentre os demais.
 O bubble sort assim como o couting é quadrático, entretando, não cria vetores
 auxiliares e tem menor tempo de execução por possuir um laço de repetição
 a menos, é melhor que o couting sort mas pior que os demais algoritmos.
 O insertion sort é o melhor dos algoritmos de ordem quadrática dentre os
 apresentados neste trabalho, seu tempo de execução é inferior ao couting
 e ao bubble e não utiliza vetores auxiliares em seu método, entretanto,
 em comparação com outros algoritmos de ordem linear tem tempo de execução
 muito alto.
 O merge sort, de ordem 
\begin_inset Formula $nlogn$
\end_inset

 tem tempo de execução inferior a todos os algorimos quadráticos mostrados
 neste trabalho, entretanto, utiliza memória auxiliar por conta de sua pilha
 de execução e criação de vetores auxiliares.
 O quick sort, também de complexidade 
\begin_inset Formula $nlogn$
\end_inset

, tem em seu caso médio tempo de execução menor que o merge sort e todos
 os algoritmos quadráticos, não utiliza vetores auxiliares e seu gasto de
 memória é em função à sua pilha de execução, é em quase todos os casos
 o melhor algorimo a se utilizar.
 O distribution sort é o algoritmo mais rápido dentre os outros, entretando,
 seu uso de memória é em função da diferença do maior e menor elemento do
 vetor, tornando seu uso perigoso.
 Em casos que o consumo de memória não é o problema, o distribution sort
 é o melhor algoritmo a se utilizar.
\end_layout

\begin_layout Standard
Em relação aos algoritmos de busca apresentados, exceto no melhor caso de
 ambos, a busca binária leva vantagem sobre a busca linear em relação ao
 tempo de execução, em contrapartida tem um custo de memória maior pois
 é em função do tamanho da pilha de execução gerada.
 Então, se memória não for um problema e o elemento buscado não estiver
 na primeira posição do vetor (melhor caso de ambos) a melhor opção para
 se utilizar é a busca binária; caso o elemento esteja na primeira posição
 do vetor e/ou o consumo de memória por um problema, a busca linear é mais
 recomendada.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "1"
literal "false"

\end_inset

Levitin, A..
 Introduction to the Design and Analysis of Algorithms.
 2.
 Addison Wesley.
 2006
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "2"
literal "false"

\end_inset

Cormen, T.H.; Leiserson, C.E.; Rivest, R.L.; Stein, C..
 Introduction to Algorithms.
 3.
 The MIT Press.
 2009
\end_layout

\end_body
\end_document
